{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isNil from \"lodash/isNil\";\nimport { shallowEqual, CHECK_STATE } from '../utils';\nimport { getChildrenByFlattenNodes } from '../utils/treeUtils';\nexport function isEveryChildChecked(nodes, parent) {\n  if (_isNil(parent.refKey) || _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n\n  var children = getChildrenByFlattenNodes(nodes, parent);\n\n  if (!children.length) {\n    var _nodes$parent$refKey$;\n\n    return (_nodes$parent$refKey$ = nodes[parent.refKey].check) !== null && _nodes$parent$refKey$ !== void 0 ? _nodes$parent$refKey$ : false;\n  }\n\n  return children.every(function (child) {\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\nexport function isSomeChildChecked(nodes, parent, childrenKey) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n\n  var children = getChildrenByFlattenNodes(nodes, parent);\n  return children.some(function (child) {\n    var _child$childrenKey;\n\n    if ((child === null || child === void 0 ? void 0 : (_child$childrenKey = child[childrenKey]) === null || _child$childrenKey === void 0 ? void 0 : _child$childrenKey.length) > 0) {\n      return isSomeChildChecked(nodes, child, childrenKey);\n    }\n\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\nexport function isSomeNodeHasChildren(data, childrenKey) {\n  return data.some(function (node) {\n    return node[childrenKey];\n  });\n}\n/**\n * is all siblings nodes is uncheckable\n * @param {*} node\n */\n\nexport function isAllSiblingNodeUncheckable(node, nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  var parentNodeRefKey = node.parent ? node.parent.refKey : '';\n  Object.keys(nodes).forEach(function (refKey) {\n    var _curNode$parent;\n\n    var curNode = nodes[refKey];\n\n    if (_isNil(node.parent) && _isNil(curNode.parent)) {\n      list.push(curNode);\n    } else if (((_curNode$parent = curNode.parent) === null || _curNode$parent === void 0 ? void 0 : _curNode$parent.refKey) === parentNodeRefKey) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n/**\n * get each first level node uncheckable state\n */\n\nexport function isEveryFirstLevelNodeUncheckable(nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  Object.keys(nodes).forEach(function (refKey) {\n    var curNode = nodes[refKey];\n\n    if (!curNode.parent) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n/**\n * get node uncheckable state\n * @param {*} node\n */\n\nexport function isNodeUncheckable(node, props) {\n  var _props$uncheckableIte = props.uncheckableItemValues,\n      uncheckableItemValues = _props$uncheckableIte === void 0 ? [] : _props$uncheckableIte,\n      valueKey = props.valueKey;\n  return uncheckableItemValues.some(function (value) {\n    return shallowEqual(node[valueKey], value);\n  });\n}\nexport function getFormattedTree(data, nodes, props) {\n  var childrenKey = props.childrenKey,\n      cascade = props.cascade;\n  return data.map(function (node) {\n    var formatted = _extends({}, node);\n\n    var curNode = nodes[node.refKey];\n\n    if (curNode) {\n      var _node;\n\n      var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n        node: curNode,\n        cascade: cascade,\n        nodes: nodes,\n        childrenKey: childrenKey\n      }) : undefined;\n      formatted.check = curNode.check;\n      formatted.expand = curNode.expand;\n      formatted.uncheckable = curNode.uncheckable;\n      formatted.parent = curNode.parent;\n      formatted.checkState = checkState;\n\n      if (((_node = node[childrenKey]) === null || _node === void 0 ? void 0 : _node.length) > 0) {\n        formatted[childrenKey] = getFormattedTree(formatted[childrenKey], nodes, props);\n      }\n    }\n\n    return formatted;\n  });\n}\nexport function getDisabledState(nodes, node, props) {\n  var _props$disabledItemVa = props.disabledItemValues,\n      disabledItemValues = _props$disabledItemVa === void 0 ? [] : _props$disabledItemVa,\n      valueKey = props.valueKey;\n\n  if (!_isNil(node.refKey) && _isNil(nodes[node.refKey])) {\n    return false;\n  }\n\n  return disabledItemValues.some(function (value) {\n    return shallowEqual(nodes[node.refKey][valueKey], value);\n  });\n}\nexport function getCheckTreePickerDefaultValue(value, uncheckableItemValues) {\n  if (Array.isArray(value)) {\n    return value.filter(function (v) {\n      return !uncheckableItemValues.includes(v);\n    });\n  }\n\n  return [];\n}\nexport function getSelectedItems(nodes, value, valueKey) {\n  var checkItems = [];\n  Object.keys(nodes).map(function (refKey) {\n    var node = nodes[refKey];\n\n    if (value.some(function (value) {\n      return shallowEqual(node[valueKey], value);\n    })) {\n      checkItems.push(node);\n    }\n  });\n  return checkItems;\n}\nexport function getNodeCheckState(_ref) {\n  var nodes = _ref.nodes,\n      node = _ref.node,\n      cascade = _ref.cascade,\n      childrenKey = _ref.childrenKey;\n\n  if (_isNil(nodes[node.refKey])) {\n    return CHECK_STATE.UNCHECK;\n  }\n\n  if (!node[childrenKey] || !node[childrenKey].length || !cascade) {\n    nodes[node.refKey].checkAll = false;\n    return node.check ? CHECK_STATE.CHECK : CHECK_STATE.UNCHECK;\n  }\n\n  if (isEveryChildChecked(nodes, node)) {\n    nodes[node.refKey].checkAll = true;\n    nodes[node.refKey].check = true;\n    return CHECK_STATE.CHECK;\n  }\n\n  if (isSomeChildChecked(nodes, node, childrenKey)) {\n    nodes[node.refKey].checkAll = false;\n    return CHECK_STATE.INDETERMINATE;\n  }\n\n  return CHECK_STATE.UNCHECK;\n}","map":{"version":3,"sources":["/Users/pango/Documents/Open/opener/frontend/node_modules/rsuite/esm/CheckTreePicker/utils.js"],"names":["_extends","_isUndefined","_isNil","shallowEqual","CHECK_STATE","getChildrenByFlattenNodes","isEveryChildChecked","nodes","parent","refKey","children","length","_nodes$parent$refKey$","check","every","child","isSomeChildChecked","childrenKey","some","_child$childrenKey","isSomeNodeHasChildren","data","node","isAllSiblingNodeUncheckable","uncheckableItemValues","valueKey","list","parentNodeRefKey","Object","keys","forEach","_curNode$parent","curNode","push","isNodeUncheckable","isEveryFirstLevelNodeUncheckable","props","_props$uncheckableIte","value","getFormattedTree","cascade","map","formatted","_node","checkState","getNodeCheckState","undefined","expand","uncheckable","getDisabledState","_props$disabledItemVa","disabledItemValues","getCheckTreePickerDefaultValue","Array","isArray","filter","v","includes","getSelectedItems","checkItems","_ref","UNCHECK","checkAll","CHECK","INDETERMINATE"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isNil from \"lodash/isNil\";\nimport { shallowEqual, CHECK_STATE } from '../utils';\nimport { getChildrenByFlattenNodes } from '../utils/treeUtils';\nexport function isEveryChildChecked(nodes, parent) {\n  if (_isNil(parent.refKey) || _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n\n  var children = getChildrenByFlattenNodes(nodes, parent);\n\n  if (!children.length) {\n    var _nodes$parent$refKey$;\n\n    return (_nodes$parent$refKey$ = nodes[parent.refKey].check) !== null && _nodes$parent$refKey$ !== void 0 ? _nodes$parent$refKey$ : false;\n  }\n\n  return children.every(function (child) {\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\nexport function isSomeChildChecked(nodes, parent, childrenKey) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n\n  var children = getChildrenByFlattenNodes(nodes, parent);\n  return children.some(function (child) {\n    var _child$childrenKey;\n\n    if ((child === null || child === void 0 ? void 0 : (_child$childrenKey = child[childrenKey]) === null || _child$childrenKey === void 0 ? void 0 : _child$childrenKey.length) > 0) {\n      return isSomeChildChecked(nodes, child, childrenKey);\n    }\n\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\nexport function isSomeNodeHasChildren(data, childrenKey) {\n  return data.some(function (node) {\n    return node[childrenKey];\n  });\n}\n/**\n * is all siblings nodes is uncheckable\n * @param {*} node\n */\n\nexport function isAllSiblingNodeUncheckable(node, nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  var parentNodeRefKey = node.parent ? node.parent.refKey : '';\n  Object.keys(nodes).forEach(function (refKey) {\n    var _curNode$parent;\n\n    var curNode = nodes[refKey];\n\n    if (_isNil(node.parent) && _isNil(curNode.parent)) {\n      list.push(curNode);\n    } else if (((_curNode$parent = curNode.parent) === null || _curNode$parent === void 0 ? void 0 : _curNode$parent.refKey) === parentNodeRefKey) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n/**\n * get each first level node uncheckable state\n */\n\nexport function isEveryFirstLevelNodeUncheckable(nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  Object.keys(nodes).forEach(function (refKey) {\n    var curNode = nodes[refKey];\n\n    if (!curNode.parent) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n/**\n * get node uncheckable state\n * @param {*} node\n */\n\nexport function isNodeUncheckable(node, props) {\n  var _props$uncheckableIte = props.uncheckableItemValues,\n      uncheckableItemValues = _props$uncheckableIte === void 0 ? [] : _props$uncheckableIte,\n      valueKey = props.valueKey;\n  return uncheckableItemValues.some(function (value) {\n    return shallowEqual(node[valueKey], value);\n  });\n}\nexport function getFormattedTree(data, nodes, props) {\n  var childrenKey = props.childrenKey,\n      cascade = props.cascade;\n  return data.map(function (node) {\n    var formatted = _extends({}, node);\n\n    var curNode = nodes[node.refKey];\n\n    if (curNode) {\n      var _node;\n\n      var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n        node: curNode,\n        cascade: cascade,\n        nodes: nodes,\n        childrenKey: childrenKey\n      }) : undefined;\n      formatted.check = curNode.check;\n      formatted.expand = curNode.expand;\n      formatted.uncheckable = curNode.uncheckable;\n      formatted.parent = curNode.parent;\n      formatted.checkState = checkState;\n\n      if (((_node = node[childrenKey]) === null || _node === void 0 ? void 0 : _node.length) > 0) {\n        formatted[childrenKey] = getFormattedTree(formatted[childrenKey], nodes, props);\n      }\n    }\n\n    return formatted;\n  });\n}\nexport function getDisabledState(nodes, node, props) {\n  var _props$disabledItemVa = props.disabledItemValues,\n      disabledItemValues = _props$disabledItemVa === void 0 ? [] : _props$disabledItemVa,\n      valueKey = props.valueKey;\n\n  if (!_isNil(node.refKey) && _isNil(nodes[node.refKey])) {\n    return false;\n  }\n\n  return disabledItemValues.some(function (value) {\n    return shallowEqual(nodes[node.refKey][valueKey], value);\n  });\n}\nexport function getCheckTreePickerDefaultValue(value, uncheckableItemValues) {\n  if (Array.isArray(value)) {\n    return value.filter(function (v) {\n      return !uncheckableItemValues.includes(v);\n    });\n  }\n\n  return [];\n}\nexport function getSelectedItems(nodes, value, valueKey) {\n  var checkItems = [];\n  Object.keys(nodes).map(function (refKey) {\n    var node = nodes[refKey];\n\n    if (value.some(function (value) {\n      return shallowEqual(node[valueKey], value);\n    })) {\n      checkItems.push(node);\n    }\n  });\n  return checkItems;\n}\nexport function getNodeCheckState(_ref) {\n  var nodes = _ref.nodes,\n      node = _ref.node,\n      cascade = _ref.cascade,\n      childrenKey = _ref.childrenKey;\n\n  if (_isNil(nodes[node.refKey])) {\n    return CHECK_STATE.UNCHECK;\n  }\n\n  if (!node[childrenKey] || !node[childrenKey].length || !cascade) {\n    nodes[node.refKey].checkAll = false;\n    return node.check ? CHECK_STATE.CHECK : CHECK_STATE.UNCHECK;\n  }\n\n  if (isEveryChildChecked(nodes, node)) {\n    nodes[node.refKey].checkAll = true;\n    nodes[node.refKey].check = true;\n    return CHECK_STATE.CHECK;\n  }\n\n  if (isSomeChildChecked(nodes, node, childrenKey)) {\n    nodes[node.refKey].checkAll = false;\n    return CHECK_STATE.INDETERMINATE;\n  }\n\n  return CHECK_STATE.UNCHECK;\n}"]},"metadata":{},"sourceType":"module"}